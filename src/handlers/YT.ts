import { AsyncNedb } from "nedb-async";
import {
  PendleYieldTokenContext,
  RedeemInterestEvent,
  TransferEvent,
} from "../types/eth/pendleyieldtoken.js";
import { MISC_CONSTS, PENDLE_POOL_ADDRESSES } from "../consts.js";
import { getDbPath, getUnixTimestamp, isPendleAddress } from "../helper.js";
import { readAllUserERC20Balances, readAllYTPositions } from "../multicall.js";
import { EVENT_USER_SHARE, POINT_SOURCE_YT, PointAmounts } from "../types.js";
import {
  calcPointsFromHolding,
  updateUserPoint,
} from "../points/point-manager.js";

/**
 * @dev 1 YT EZETH is entitled to yields and points generated by 1 ETH worth of EZETH (0.997... something)
 */

const db = new AsyncNedb({
  filename: getDbPath("pendle-accounts-yt"),
  autoload: true,
});

db.persistence.setAutocompactionInterval(60 * 1000);

type AccountSnapshot = {
  _id: string;
  lastUpdatedAt: number;
  lastImpliedHolding: string;
};

export async function handleYTTransfer(
  evt: TransferEvent,
  ctx: PendleYieldTokenContext
) {
  await updateAllYTAccounts(
    ctx,
    [evt.args.from.toLowerCase(), evt.args.to.toLowerCase()],
    false
  );
}

export async function handleYTRedeemInterest(
  evt: RedeemInterestEvent,
  ctx: PendleYieldTokenContext
) {
  await updateAllYTAccounts(ctx, [evt.args.user.toLowerCase()], false);
}

export async function updateAllYTAccounts(
  ctx: PendleYieldTokenContext,
  addressesToAdd: string[] = [],
  shouldIncludeDb: boolean = true
) {
  if (await ctx.contract.isExpired()) {
    return;
  }

  const allAddresses = shouldIncludeDb
    ? (await db.asyncFind<AccountSnapshot>({})).map((x) => x._id)
    : [];
  for (let address of addressesToAdd) {
    address = address.toLowerCase();
    if (!allAddresses.includes(address) && !isPendleAddress(address)) {
      allAddresses.push(address);
    }
  }

  const timestamp = getUnixTimestamp(ctx.timestamp);
  const allYTBalances = await readAllUserERC20Balances(
    ctx,
    allAddresses,
    ctx.contract.address
  );
  const allYTPositions = await readAllYTPositions(ctx, allAddresses);

  const treasuryPoints: PointAmounts = {
    ezPoint: 0n,
    elPoint: 0n,
  };

  await Promise.all(
    allAddresses.map(async (address, i) => {
      const balance = allYTBalances[i];
      const interestData = allYTPositions[i];

      const snapshot = await db.asyncFindOne<AccountSnapshot>({ _id: address });
      if (snapshot && snapshot.lastUpdatedAt < timestamp) {
        const pointsBeforeFees = calcPointsFromHolding(
          ctx,
          BigInt(snapshot.lastImpliedHolding),
          BigInt(timestamp - snapshot.lastUpdatedAt)
        );
        const fees: PointAmounts = {
          ezPoint: (pointsBeforeFees.ezPoint * 3n) / 100n,
          elPoint: (pointsBeforeFees.elPoint * 3n) / 100n,
        };

        treasuryPoints.ezPoint += fees.ezPoint;
        treasuryPoints.elPoint += fees.elPoint;
        await updateUserPoint(address, POINT_SOURCE_YT, {
          ezPoint: pointsBeforeFees.ezPoint - fees.ezPoint,
          elPoint: pointsBeforeFees.elPoint - fees.elPoint,
        });
      }

      if (interestData.lastPYIndex == 0n) return;

      const impliedHolding =
        (balance * MISC_CONSTS.ONE_E18) / interestData.lastPYIndex +
        interestData.accruedInterest;

      const newSnapshot = {
        _id: address,
        lastUpdatedAt: timestamp,
        lastImpliedHolding: impliedHolding.toString(),
      };
      await db.asyncUpdate({ _id: address }, newSnapshot, { upsert: true });
    })
  );

  await updateUserPoint(
    PENDLE_POOL_ADDRESSES.TREASURY,
    POINT_SOURCE_YT,
    treasuryPoints
  );
}
